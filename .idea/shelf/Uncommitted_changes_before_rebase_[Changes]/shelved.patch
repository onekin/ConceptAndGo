Index: app/scripts/cmapCloudPage.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import HypothesisClientManager from './annotationServer/hypothesis/HypothesisClientManager'\nimport _ from 'lodash'\nimport LanguageUtils from './utils/LanguageUtils'\nimport Alerts from './utils/Alerts'\nimport Config from './Config'\nimport CXLImporter from './importExport/cmap/CXLImporter'\n// import swal from 'sweetalert2'\nimport Codebook from './codebook/model/Codebook'\nimport { CXLExporter } from './importExport/cmap/CXLExporter'\nimport CmapCloudClient from './importExport/cmap/cmapCloud/CmapCloudClient'\nlet noteOpened = false\n\nconst kudeatzaileakHasieratu = function () {\n  const checkDOM = setInterval(function () {\n    let noteOpened = false\n    window.cag = {}\n    window.cag.annotations = []\n    window.cag.annotationServerManager = new HypothesisClientManager()\n    window.cag.annotationServerManager.init((err) => {\n      if (err) {\n        window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n      } else {\n        window.cag.annotationServerManager.isLoggedIn((err, result) => {\n          if (err || !result) {\n            if (LanguageUtils.isInstanceOf(window.cag.annotationServerManager, HypothesisClientManager)) {\n              window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n            }\n          } else {\n            const listElement = document.querySelector('li > a#create-url-res')\n            if (listElement) {\n              const newListElement = document.createElement('li')\n              const aElement = document.createElement('a')\n              aElement.style.fontSize = '12px'\n              aElement.style.lineHeight = '14px'\n              aElement.style.color = '#4682b4'\n              aElement.id = 'conceptGoLabel'\n              aElement.innerText = 'New annotation-driven Cmap'\n              aElement.style.fontWeight = 'normal'\n              aElement.addEventListener('click', () => {\n                chrome.runtime.sendMessage({ scope: 'cmapCloud', cmd: 'getUserData' }, (response) => {\n                  if (response.data) {\n                    const data = response.data\n                    if (data.userData.user && data.userData.password && data.userData.uid) {\n                      const cmapCloudClient = new CmapCloudClient(data.userData.user, data.userData.password, data.userData.uid)\n                      console.log('createTask')\n                      // createTask()\n                      createWindow(cmapCloudClient, data.userData)\n                    } else {\n                      let callback = () => {\n                        window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n                      }\n                      Alerts.infoAlert({\n                        text: 'Please, provide us your Cmap Cloud login credentials in the configuration page of the Web extension.',\n                        title: 'We need your Cmap Cloud credentials',\n                        callback: callback()\n                      })\n                    }\n                  } else {\n                    let callback = () => {\n                      window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n                    }\n                    Alerts.infoAlert({\n                      text: 'Please, provide us your Cmap Cloud login credentials in the configuration page of the Web extension.',\n                      title: 'We need your Cmap Cloud credentials',\n                      callback: callback()\n                    })\n                  }\n                })\n              })\n              aElement.addEventListener('mouseenter', () => {\n                aElement.style.fontWeight = 'bold'\n              })\n              aElement.addEventListener('mouseleave', () => {\n                aElement.style.fontSize = '12px'\n                aElement.style.lineHeight = '14px'\n                aElement.id = 'conceptGoLabel'\n                aElement.style.fontWeight = 'normal'\n              })\n              newListElement.appendChild(aElement)\n              listElement.parentNode.parentNode.insertBefore(newListElement, listElement.parentNode.parentNode.firstChild)\n            }\n            // Options for the observer (which mutations to observe)\n            const config = { attributes: true, childList: true, subtree: true }\n            // Callback function to execute when mutations are observed\n            const callback = (mutationList, observer) => {\n              for (const mutation of mutationList) {\n                if (mutation.type === 'childList') {\n                  if (mutation.addedNodes) {\n                    if (mutation.addedNodes.length > 0) {\n                      // console.log('added nodes', mutation.addedNodes)\n                      const node = mutation.addedNodes[0]\n                      if (node.className && node.className === 'gwt-PopupPanel') {\n                        console.log('OPEN')\n                        // Check if the parent div contains a child div with class \"gwt-Label\" and inner text \"Annotation\"\n                        const isAnnotationNote = node.outerHTML.includes('<div class=\"gwt-Label\" style=\"position: absolute; left: 2px; top: 0px;\">Annotation</div>')\n                        const isContextMenu = node.outerHTML.includes('<td class=\"gwt-MenuItem\" id=\"gwt-uid-3\" role=\"menuitem\" colspan=\"2\">Annotate...</td>')\n                        if (isAnnotationNote) {\n                          console.log(\"OPEN ANNOTATION'.\")\n                          showFeedbackNoteFirstTime(node)\n                        } else if (isContextMenu) {\n                          const contextMenuFeedbackLabel = document.getElementById('gwt-uid-3')\n                          contextMenuFeedbackLabel.innerText = 'Feedback...'\n                        }\n                        addToolTipToAnnotations(node)\n                      } else if (node.innerText === 'Change Properties...') {\n                        loadAnnotations()\n                      } else if (node.innerText === 'New Cmap') {\n                        const listElement = document.querySelector('li > a#create-url-res')\n                        const conceptGoLabel = document.querySelector('li > a#conceptGoLabel')\n                        if (listElement && !conceptGoLabel) {\n                          const newListElement = document.createElement('li')\n                          const aElement = document.createElement('a')\n                          aElement.style.fontSize = '12px'\n                          aElement.style.lineHeight = '14px'\n                          aElement.style.color = '#4682b4'\n                          aElement.id = 'conceptGoLabel'\n                          aElement.innerText = 'New annotation-driven Cmap'\n                          aElement.addEventListener('click', () => {\n                            chrome.runtime.sendMessage({ scope: 'cmapCloud', cmd: 'getUserData' }, (response) => {\n                              if (response.data) {\n                                const data = response.data\n                                if (data.userData.user && data.userData.password && data.userData.uid) {\n                                  const cmapCloudClient = new CmapCloudClient(data.userData.user, data.userData.password, data.userData.uid)\n                                  console.log('createTask')\n                                  // createTask()\n                                  createWindow(cmapCloudClient, data.userData)\n                                } else {\n                                  let callback = () => {\n                                    window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n                                  }\n                                  Alerts.infoAlert({\n                                    text: 'Please, provide us your Cmap Cloud login credentials in the configuration page of the Web extension.',\n                                    title: 'We need your Cmap Cloud credentials',\n                                    callback: callback()\n                                  })\n                                }\n                              } else {\n                                let callback = () => {\n                                  window.open(chrome.extension.getURL('pages/options.html#cmapCloudConfiguration'))\n                                }\n                                Alerts.infoAlert({\n                                  text: 'Please, provide us your Cmap Cloud login credentials in the configuration page of the Web extension.',\n                                  title: 'We need your Cmap Cloud credentials',\n                                  callback: callback()\n                                })\n                              }\n                            })\n                          })\n                          aElement.addEventListener('mouseenter', () => {\n                            aElement.style.fontWeight = 'bold'\n                          })\n                          aElement.addEventListener('mouseleave', () => {\n                            aElement.style.fontSize = '12px'\n                            aElement.style.lineHeight = '14px'\n                            aElement.id = 'conceptGoLabel'\n                            aElement.innerText = 'New annotation-driven Cmap'\n                            aElement.style.fontWeight = 'normal'\n                          })\n                          newListElement.appendChild(aElement)\n                          listElement.parentNode.parentNode.insertBefore(newListElement, listElement.parentNode.parentNode.firstChild)\n                        }\n                      } else if (node.className === 'res-meta-dialog ui-dialog-content ui-widget-content') {\n                        node.style.height = '230px'\n                        updateProperties(node)\n                      }\n                    }\n                  } else {\n                    console.log('removed node', mutation.removedNodes)\n                  }\n                } if (mutation.type === 'attributes' && mutation.attributeName === 'style' && !noteOpened) {\n                  const targetNode = mutation.target\n                  const newVisibilityValue = targetNode.getAttribute('style')\n                  const noteLabel = targetNode.querySelectorAll('.gwt-Label')[0]\n                  if ((targetNode.className === 'gwt-PopupPanel') && (newVisibilityValue.includes('visibility: visible;')) && (noteLabel && noteLabel.innerText === 'Feedback')) {\n                    noteOpened = true\n                    showFeedbackNote(targetNode)\n                    changeNoteOpenedValue()\n                  }\n                }\n              }\n            }\n            // Create an observer instance linked to the callback function\n            const observer = new MutationObserver(callback)\n            // Start observing the target node for configured mutations\n            observer.observe(document.body, config)\n          }\n        })\n      }\n    })\n    clearInterval(checkDOM)\n  }, 1000)\n}\n\nconst createTask = function (groupName, focusQuestion, dimensionString, userData, urlInput) {\n  groupName = LanguageUtils.normalizeString(groupName)\n  if (groupName.length > 25) {\n    groupName = groupName.substring(0, 24)\n  }\n  window.cag.annotationServerManager.client.createNewGroup({ name: groupName, description: 'A group created using Concept&Go' + chrome.runtime.getManifest().name }, (err, newGroup) => {\n    if (err) {\n      window.alert('Unable to load swal. Please contact developer.')\n    } else {\n      if (_.isString(dimensionString)) {\n        let urlList\n        if (urlInput && _.isString(urlInput)) {\n          urlList = urlInput.split(';')\n          urlList.forEach(element => element.trim)\n        }\n        const dimensionsList = dimensionString.split(';')\n        dimensionsList.forEach(element => element.trim)\n        groupName = LanguageUtils.normalizeString(groupName)\n        let tempCodebook\n        if (urlList) {\n          tempCodebook = Codebook.fromCXLFile(null, dimensionsList, groupName, focusQuestion, [], urlInput)\n        } else {\n          tempCodebook = Codebook.fromCXLFile(null, dimensionsList, groupName, focusQuestion, [], null)\n        }\n        Codebook.setAnnotationServer(newGroup.id, (annotationServer) => {\n          tempCodebook.annotationServer = annotationServer\n          const topicThemeObject = _.filter(tempCodebook.themes, (theme) => {\n            return theme.topic === groupName || theme.name === groupName\n          })\n          topicThemeObject[0].isTopic = true\n          const annotations = tempCodebook.toAnnotations()\n          // Send create highlighter\n          window.cag.annotationServerManager.client.createNewAnnotations(annotations, (err, codebookAnnotations) => {\n            if (err) {\n              Alerts.errorAlert({ text: 'Unable to create new group.' })\n            } else {\n              Codebook.fromAnnotations(codebookAnnotations, (err, codebook) => {\n                if (err) {\n                  Alerts.errorAlert({ text: 'Unable to create codebook.' })\n                } else {\n                  CXLExporter.createCmapFromCmapCloud(newGroup, codebook, groupName, userData)\n                  const window = document.getElementById('windowDialog')\n                  const background = document.getElementById('windowBackground')\n                  window.remove()\n                  background.remove()\n                  Alerts.successAlert({ text: 'Annotation Group successfully created!' })\n                }\n              })\n            }\n          })\n        })\n      }\n    }\n  })\n}\n\nconst createWindow = function (cmapCloudClient, userData) {\n  const htmlString = '<div id=\"windowDialog\" tabIndex=\"-1\" role=\"dialog\" style=\"position: absolute; height: auto; width: 450px; top: 425px; left: 332px; display: block;\" aria-describedby=\"ui-id-36\" aria-labelledby=\"ui-id-37\"> ' +\n    '<div id=\"windowHeader\">' +\n    '<span id=\"windowDialogTitle\">Creating new annotation driven concept map</span> ' +\n    '</div> ' +\n    '<div id=\"windowMetadata\" style=\"display: block; width: auto; min-height: 0px; max-height: none; height: 265px;\">' +\n    '<form>' +\n    '<label htmlFor=\"rmeta_name\" class=\"windowLabel\">What is the name of your Cmap?</label><input placeholder=\"Cmap name..\" type=\"text\" name=\"name\" id=\"rmeta_name\" class=\"windowInput\">' +\n    '<label class=\"windowLabel\" htmlFor=\"rmeta_focus_question\">What is the focus question?</label><input placeholder=\"Focus question...\" type=\"text\" name=\"focus_question\" id=\"rmeta_focus_question\" class=\"windowInput\">' +\n    '<label class=\"windowLabel\" htmlFor=\"rmeta_keywords\">Which are the Categories? (separate them using semicolons;)</label><input placeholder=\"Category1;Category2...\" type=\"text\" name=\"keywords\" id=\"rmeta_keywords\" class=\"windowInput\">' +\n    '<label class=\"windowLabel\" htmlFor=\"rmeta_urls\">Which are the Reading materials? (separate URLs using semicolons;)</label><input placeholder=\"URL1;URL2...\" type=\"text\" name=\"urls\" id=\"rmeta_urls\" class=\"windowInput\">' +\n    '</form> </div> ' +\n    '<div id=\"windowButtonPane\"> ' +\n    '<div id=\"windowButtonSet\"\"> ' +\n    '<span id=\"windowErrorMessage\" style=\"margin-left: 10px;\"></span>' +\n    '<button class=\"windowButton\" type=\"button\" id=\"cancelBtn\" role=\"button\"><span class=\"windowButtonSpan\">Cancel</span></button> ' +\n    '<button class=\"windowButton\" type=\"button\" id=\"createMapBtn\" role=\"button\"><span class=\"windowButtonSpan\">Create Cmap</span></button> ' +\n    '</div></div></div>'\n  const parser = new DOMParser()\n  const html = parser.parseFromString(htmlString, 'text/html')\n  let window = html.querySelector('div')\n  document.body.appendChild(window)\n  window = document.getElementById('windowDialog')\n  window.style.zIndex = '5000'\n  const backgroundHTMLDiv = document.createElement('div')\n  backgroundHTMLDiv.id = 'windowBackground'\n  backgroundHTMLDiv.style.zIndex = '4999'\n  window.parentNode.insertBefore(backgroundHTMLDiv, window.nextSibling)\n  const background = document.getElementById('windowBackground')\n  // Define buttons\n  const createMapBtn = document.getElementById('createMapBtn')\n  createMapBtn.onclick = () => {\n    const errorMessage = document.getElementById('windowErrorMessage')\n    checkFormData(cmapCloudClient, (message) => {\n      if (message === 'OK') {\n        const nameInput = document.getElementById('rmeta_name')\n        const focusQuestionInput = document.getElementById('rmeta_focus_question')\n        const categoriesInput = document.getElementById('rmeta_keywords')\n        const urlInput = document.getElementById('rmeta_urls')\n        errorMessage.style.color = '#006400'\n        errorMessage.textContent = 'Creating annotation group...'\n        createTask(nameInput.value, focusQuestionInput.value, categoriesInput.value, userData, urlInput.value)\n      } else {\n        errorMessage.style.color = '#8B0000'\n        errorMessage.textContent = message\n      }\n    })\n  }\n  const cancelBtn = document.getElementById('cancelBtn')\n  cancelBtn.onclick = () => {\n    console.log('cancelBtn')\n    window.remove()\n    background.remove()\n  }\n}\n\nconst getURLFromSelectedAnnotation = function (selectedAnnotation) {\n  console.log(window.cag.annotations)\n  const id = selectedAnnotation.slice(-22)\n  console.log(id)\n  let url\n  if (window.cag.annotations.length > 0) {\n    const annotation = window.cag.annotations.find((anno) => {\n      return anno.id === id\n    })\n    url = annotation.target[0].source + '#' + Config.urlParamName + ':' + annotation.id\n  }\n  return url\n}\n\nconst getTextFromSelectedAnnotation = function (selectedAnnotation) {\n  let text\n  console.log(window.cag.annotations)\n  const id = selectedAnnotation.slice(-22)\n  console.log(id)\n  if (window.cag.annotations.length > 0) {\n    const annotation = window.cag.annotations.find((anno) => {\n      return anno.id === id\n    })\n    if (annotation && annotation.target[0] && annotation.target[0].selector) {\n      const textQuote = annotation.target[0].selector.find((sel) => {\n        return sel.type === 'TextQuoteSelector'\n      })\n      if (textQuote) {\n        text = textQuote.exact\n      }\n    }\n  }\n  return text\n}\n\nconst addToolTipToAnnotations = function (node) {\n  const annotations = node.children[0].children[0].children[0].children\n  for (let i = 0; i < annotations.length; i++) {\n    const id = annotations[i].innerText.slice(-22)\n    console.log(id)\n    if (window.cag.annotations.length > 0) {\n      const annotation = window.cag.annotations.find((anno) => {\n        return anno.id === id\n      })\n      const textQuote = annotation.target[0].selector.find((sel) => {\n        return sel.type === 'TextQuoteSelector'\n      })\n      let text\n      if (textQuote) {\n        text = textQuote.exact\n      }\n      annotations[i].classList.add('tooltipCmap')\n      const span = document.createElement('span')\n      span.className = 'tooltiptextCmap'\n      span.innerText = text\n      annotations[i].appendChild(span)\n    }\n  }\n}\n\nconst loadAnnotations = function () {\n  console.log('YOU HAVE OPEN A MAP')\n  const list = document.querySelectorAll('.cmap-tab.active')\n  if (list.length > 0) {\n    const groupId = getGroupId(list)\n    window.cag.annotationServerManager.client.searchAnnotations({\n      group: groupId,\n      order: 'desc'\n    }, (err, annotations) => {\n      if (err) {\n        Alerts.errorAlert({\n          title: 'Log in required',\n          text: 'Annotations not found'\n        })\n      } else {\n        annotations = _.filter(annotations, (annotation) => {\n          return !annotation.motivation && annotation.motivation !== 'codebookDevelopment'\n        })\n        window.cag.annotations = annotations\n      }\n    })\n  }\n}\n\nconst checkFormData = function (cmapCloudClient, callback) {\n  getFolderNames(cmapCloudClient, (folderNames) => {\n    let message = 'OK'\n    const nameInput = document.getElementById('rmeta_name')\n    const focusQuestionInput = document.getElementById('rmeta_focus_question')\n    const categoriesInput = document.getElementById('rmeta_keywords')\n    const urlsInput = document.getElementById('rmeta_urls')\n    let urlList = []\n    let dimensionsList = []\n    try {\n      dimensionsList = categoriesInput.value.split(';').filter(Boolean)\n    } catch (e) {\n      message = 'Error parsing categories'\n    }\n    try {\n      urlList = urlsInput.value.split(';').filter(Boolean)\n    } catch (e) {\n      message = 'Error parsing urls'\n    }\n    if (folderNames && folderNames.includes(nameInput.value)) {\n      message = 'Cmap name already exist'\n    }\n    if (nameInput.value.length < 5) {\n      message = 'Provide a larger Cmap name'\n    } else if (focusQuestionInput.value < 5) {\n      message = 'Provide a larger focus question'\n    } else if (!dimensionsList || dimensionsList.length < 1 || categoriesInput.value === '') {\n      message = 'Provide categories'\n    } else if (!urlList || urlList.length < 1 || urlsInput.value === '') {\n      message = 'Provide URLs'\n    } else if (urlList && urlList.length > 0) {\n      urlList.forEach(url => {\n        if (!isURL(url)) {\n          message = 'A provided URL is incorrect'\n        }\n      })\n    }\n    callback(message)\n  })\n}\n\nfunction isURL (string) {\n  // Regular expression pattern to match a URL\n  let urlPattern = /^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i\n  // Test if the string matches the URL pattern\n  return urlPattern.test(string)\n}\n\nconst getFolderNames = function (cmapCloudClient, callback) {\n  cmapCloudClient.getRootFolderInfor((data) => {\n    const elements = data.getElementsByTagName('res-meta')\n    if (elements.length > 0) {\n      const folderElements = _.map(_.filter(elements, (element) => {\n        if (element.attributes.format) {\n          return element.attributes.format.nodeValue === 'x-nlk-project/x-binary'\n        }\n      }), (folderElement) => {\n        return folderElement.attributes.title.nodeValue\n      })\n      callback(folderElements)\n    } else {\n      callback()\n    }\n  })\n}\n\nconst getGroupId = function (list) {\n  const name = list[0].querySelectorAll('.cmap-tab-label')\n  let groupID = name[0].innerText.slice(-10).replace('(', '').replace(')', '')\n  if (groupID.includes(')') || groupID.includes('(')) {\n    let inputString = name[0].innerText\n    // Use a regular expression to find the last occurrence of text within parentheses\n    const regex = /\\([^()]*\\)(?!.*\\([^()]*\\))/\n    inputString = inputString.replace(regex, '').trim()\n    groupID = inputString.slice(-10).replace('(', '').replace(')', '')\n    return groupID\n  } else {\n    return groupID\n  }\n}\n\nconst updateProperties = function (node) {\n  console.log('window opened')\n  node.style.height = '178.3px'\n  const keywordLabel = node.querySelector('label[for=\"rmeta_keywords\"]')\n  if (keywordLabel) {\n    keywordLabel.textContent = 'Categories (separate using semicolons(;))'\n  }\n  const languageLabel = node.querySelector('label[for=\"rmeta_language\"]')\n  if (languageLabel) {\n    languageLabel.textContent = 'Reading materials (separate URLs using semicolons(;))'\n  }\n  /* const languageInput = node.querySelector('input[name=\"language\"]')\n  if (languageInput) {\n    languageInput.style.visibility = 'hidden'\n  } */\n  const authorLabel = node.querySelector('label[for=\"rmeta_author\"]')\n  if (authorLabel) {\n    authorLabel.style.visibility = 'hidden'\n  }\n  const authorInput = node.querySelector('input[name=\"author\"]')\n  if (authorInput) {\n    authorInput.style.visibility = 'hidden'\n  }\n  const emailLabel = node.querySelector('label[for=\"rmeta_email\"]')\n  if (emailLabel) {\n    emailLabel.style.visibility = 'hidden'\n  }\n  const emailInput = node.querySelector('input[name=\"email\"]')\n  if (emailInput) {\n    emailInput.style.visibility = 'hidden'\n  }\n  const organizationLabel = node.querySelector('label[for=\"rmeta_organization\"]')\n  if (organizationLabel) {\n    organizationLabel.style.visibility = 'hidden'\n  }\n  const organizationInput = node.querySelector('input[name=\"organization\"]')\n  if (organizationInput) {\n    organizationInput.style.visibility = 'hidden'\n  }\n}\n\nconst showFeedbackNote = function (targetNode) {\n  console.log('Visibility attribute changed to Feedback note')\n  const textArea = targetNode.querySelector('textarea.gwt-TextArea')\n  textArea.style.width = '206px'\n  textArea.style.height = '83px'\n  const firstInput = targetNode.querySelectorAll('input.gwt-TextBox')[0]\n  firstInput.style.width = textArea.style.width\n  // Change width\n  const noteDiv = targetNode.querySelector('div[tabindex=\"0\"]')\n  noteDiv.style.height = '320px'\n  noteDiv.style.width = '210px'\n  const noteChildDiv = noteDiv.querySelector('div')\n  noteChildDiv.style.overflow = 'visible'\n  // change last img\n  const lastImg = targetNode.querySelector('img.gwt-Image')\n  lastImg.style.top = '290px'\n  lastImg.style.left = '200px'\n  lastImg.style.visibility = 'hidden'\n  // change noteButton\n  const noteButton = targetNode.querySelector('div.gwt-PushButton')\n  noteButton.style.left = '192px'\n  // restore selectElement\n  const selectElement = noteDiv.querySelector('select.selectedNames')\n  selectElement.style.position = 'absolute'\n  selectElement.style.left = '2px'\n  let position = firstInput.style.top.replace('px', '')\n  position = parseInt(position) + 40\n  selectElement.style.top = position.toString() + 'px'\n  selectElement.style.width = textArea.style.width\n  /// Restore second select\n  const selectElementAnnotations = noteDiv.querySelector('select.selectedAnnotations')\n  selectElementAnnotations.style.position = 'relative'\n  selectElementAnnotations.style.left = '2px'\n  let positionSelectElementConcepts = selectElement.style.top.replace('px', '')\n  positionSelectElementConcepts = parseInt(positionSelectElementConcepts) + 30\n  selectElementAnnotations.style.top = positionSelectElementConcepts.toString() + 'px'\n  selectElementAnnotations.style.width = selectElement.style.width\n  // Add button\n  const addButton = noteDiv.querySelector('button.addButton')\n  addButton.style.position = 'relative'\n  addButton.style.left = '2px'\n  addButton.style.top = selectElementAnnotations.style.top\n  addButton.style.width = selectElementAnnotations.style.width\n  // restore annotation Div\n  const annotationDiv = targetNode.querySelector('div.annotationDiv')\n  annotationDiv.style.position = 'relative'\n  let positionAddButton = addButton.style.top.replace('px', '')\n  positionAddButton = parseInt(positionAddButton) + 5\n  annotationDiv.style.top = positionAddButton.toString() + 'px'\n  annotationDiv.style.width = addButton.style.width\n}\n\nconst showFeedbackNoteFirstTime = function (node) {\n  const noteLabel = node.querySelectorAll('.gwt-Label')[0]\n  noteLabel.innerText = 'Feedback'\n  const noteButton = node.querySelector('div.gwt-PushButton')\n  noteButton.addEventListener('click', function () {\n    // This function will be executed when the div is clicked\n    console.log('Close annotation')\n  })\n  const textArea = node.querySelector('textarea.gwt-TextArea')\n  textArea.style.width = '206px'\n  textArea.style.height = '83px'\n  const selectedElements = []\n  const firstInput = node.querySelectorAll('input.gwt-TextBox')[0]\n  firstInput.style.width = textArea.style.width\n  const secondInput = node.querySelectorAll('input.gwt-TextBox')[1]\n  if (!secondInput.value.startsWith('id:')) {\n    secondInput.value = 'id:'\n  }\n  // Format the date as a string\n  if (!isValidDateFormat(firstInput.value)) {\n    // Get the current date and time\n    const currentDate = new Date()\n    // Add an hour to the current date\n    currentDate.setHours(currentDate.getHours())\n    const formattedDate = currentDate.toLocaleString()\n    firstInput.value = formattedDate\n  }\n  secondInput.style.visibility = 'hidden'\n  // Change width\n  const noteDiv = node.querySelector('div[tabindex=\"0\"]')\n  noteDiv.style.height = '310px'\n  noteDiv.style.width = '210px'\n  const noteChildDiv = noteDiv.querySelector('div')\n  noteChildDiv.style.overflow = 'visible'\n  // change last img\n  const lastImg = node.querySelector('img.gwt-Image')\n  lastImg.style.top = '290px'\n  lastImg.style.visibility = 'hidden'\n  const canvasText = document.querySelectorAll('[CanvasType=\"Text\"]')\n  canvasText.forEach(mapElement => {\n    let buttonItem\n    const isSelectedConcept = mapElement.parentElement.parentElement.previousElementSibling\n    const isSelectedLinkingWord = mapElement.previousElementSibling\n    if (isSelectedConcept.tagName === 'rect') {\n      buttonItem = mapElement.parentElement.parentElement.querySelector('image[CanvasType=image]')\n      selectedElements.push({ elem: mapElement, buttonItem: buttonItem })\n    }\n    if (isSelectedLinkingWord.tagName === 'rect' && isSelectedLinkingWord.stroke === '#9598ff') {\n      buttonItem = mapElement.querySelector('image[CanvasType=image]')\n      console.log(buttonItem)\n      selectedElements.push({ elem: mapElement, buttonItem: buttonItem })\n    }\n  })\n  const selectedElementsNames = selectedElements.map((element) => {\n    let name = ''\n    console.log(element.elem)\n    const spans = Array.from(element.elem.children)\n    spans.forEach((spanElement) => {\n      if (spanElement.textContent === 't') {\n        name += ' '\n      } else {\n        name += spanElement.textContent\n      }\n    })\n    return name\n  })\n  console.log(selectedElementsNames)\n  //\n  // Create a select element\n  const selectElement = document.createElement('select')\n  selectElement.className = 'selectedNames gwt-TextBox'\n  selectElement.style.position = 'absolute'\n  selectElement.style.left = '2px'\n  let position = firstInput.style.top.replace('px', '')\n  position = parseInt(position) + 40\n  selectElement.style.top = position.toString() + 'px'\n  selectElement.style.width = firstInput.style.width\n  selectedElementsNames.forEach(name => {\n    const option1 = document.createElement('option')\n    option1.value = name\n    option1.text = name\n    selectElement.appendChild(option1)\n  })\n  firstInput.parentNode.insertBefore(selectElement, firstInput.nextSibling)\n  //\n  /// Create second select\n  const selectElementAnnotations = document.createElement('select')\n  selectElementAnnotations.className = 'selectedAnnotations gwt-TextBox'\n  selectElementAnnotations.style.position = 'relative'\n  selectElementAnnotations.style.left = '2px'\n  let positionSelectElementConcepts = selectElement.style.top.replace('px', '')\n  positionSelectElementConcepts = parseInt(positionSelectElementConcepts) + 30\n  selectElementAnnotations.style.top = positionSelectElementConcepts.toString() + 'px'\n  selectElementAnnotations.style.width = selectElement.style.width\n  const allAnnotations = _.uniq(Array.from(document.querySelectorAll('#cmaps-and-res-view img')).map((elem) => { return elem.getAttribute('alt') }))\n  allAnnotations.forEach(elem => {\n    const camelized = camelize(selectElement.value)\n    if (elem.includes('---' && camelized)) {\n      const optionAnnotation = document.createElement('option')\n      const highlightedText = getTextFromSelectedAnnotation(elem)\n      const url = getURLFromSelectedAnnotation(elem)\n      const id = elem.slice(-22)\n      optionAnnotation.value = elem\n      optionAnnotation.text = 'TEXT: ' + highlightedText + ' --- FROM:' + url.slice(0, -22).replace('#cag:', '')\n      // onchange selectElementAnnotations\n      selectElementAnnotations.appendChild(optionAnnotation)\n    }\n  })\n  selectElement.parentNode.insertBefore(selectElementAnnotations, selectElement.nextSibling)\n  // Add button\n  const addButton = document.createElement('button')\n  addButton.className = 'addButton'\n  addButton.innerText = 'Add annotation'\n  addButton.style.position = 'relative'\n  addButton.style.left = '2px'\n  addButton.style.top = selectElementAnnotations.style.top\n  addButton.style.width = selectElementAnnotations.style.width\n  addButton.addEventListener('click', () => {\n    const number = annotationDiv.children.length\n    const newAnchor = document.createElement('a')\n    const selectedAnnotation = selectElementAnnotations.value\n    const annotationURL = getURLFromSelectedAnnotation(selectedAnnotation)\n    const id = selectedAnnotation.slice(-22)\n    secondInput.value = secondInput.value + id + ';'\n    // Set the href attribute\n    newAnchor.href = annotationURL\n    // Set the inner text or content of the anchor\n    newAnchor.textContent = 'anno' + number + '; '\n    newAnchor.addEventListener('click', () => {\n      window.open(annotationURL)\n    })\n    annotationDiv.appendChild(newAnchor)\n  })\n  selectElementAnnotations.parentNode.insertBefore(addButton, selectElementAnnotations.nextSibling)\n  selectElement.addEventListener('change', () => {\n    selectElementAnnotations.innerHTML = ''\n    const allAnnotations = _.uniq(Array.from(document.querySelectorAll('#cmaps-and-res-view img')).map((elem) => { return elem.getAttribute('alt') }))\n    allAnnotations.forEach(elem => {\n      const camelized = camelize(selectElement.value)\n      if (elem.includes('---' && camelized)) {\n        if (elem.includes('->')) {\n          if (elem.includes('->' + camelized + '->')) {\n            const optionAnnotation = document.createElement('option')\n            const highlightedText = getTextFromSelectedAnnotation(elem)\n            const url = getURLFromSelectedAnnotation(elem)\n            const id = elem.slice(-22)\n            optionAnnotation.value = elem\n            optionAnnotation.text = 'TEXT: ' + highlightedText + ' --- FROM:' + url.slice(0, -22).replace('#cag:', '')\n            // onchange selectElementAnnotations\n            selectElementAnnotations.appendChild(optionAnnotation)\n          }\n        } else {\n          const optionAnnotation = document.createElement('option')\n          const highlightedText = getTextFromSelectedAnnotation(elem)\n          const url = getURLFromSelectedAnnotation(elem)\n          const id = elem.slice(-22)\n          optionAnnotation.value = elem\n          optionAnnotation.text = 'TEXT: ' + highlightedText + ' --- FROM:' + url.slice(0, -22).replace('#cag:', '')\n          // onchange selectElementAnnotations\n          selectElementAnnotations.appendChild(optionAnnotation)\n        }\n      }\n    })\n  })\n  const annotationDiv = document.createElement('div')\n  annotationDiv.className = 'annotationDiv'\n  annotationDiv.contentEditable = 'true'\n  annotationDiv.style.left = '2px'\n  annotationDiv.innerText = 'Annotations: '\n  annotationDiv.style.position = 'relative'\n  annotationDiv.style.top = addButton.style.top\n  annotationDiv.style.width = addButton.style.width\n  const savedIDs = secondInput.value.replace('id:', '')\n  if (savedIDs !== '') {\n    const annotationIDs = savedIDs.split(';').filter(Boolean)\n    annotationIDs.forEach(id => {\n      const number = annotationDiv.children.length\n      const newAnchor = document.createElement('a')\n      const annotationURL = getURLFromAnnotationID(id)\n      // Set the href attribute\n      newAnchor.href = annotationURL\n      // Set the inner text or content of the anchor\n      newAnchor.textContent = 'anno' + number + '; '\n      newAnchor.addEventListener('click', () => {\n        window.open(annotationURL)\n      })\n      annotationDiv.appendChild(newAnchor)\n    })\n  }\n  addButton.parentNode.insertBefore(annotationDiv, addButton.nextSibling)\n}\n\nfunction isValidDateFormat (inputString) {\n  const dateFormatRegex = /^\\d{2}\\/\\d{2}\\/\\d{4}, \\d{2}:\\d{2}:\\d{2}$/\n  return dateFormatRegex.test(inputString)\n}\n\nfunction camelize (str) {\n  return str\n    .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())\n    .replace(/[^a-zA-Z0-9]+/g, '')\n    .replace(/^[A-Z]/, firstChar => firstChar.toLowerCase())\n}\n\nfunction changeNoteOpenedValue () {\n  setTimeout(() => {\n    noteOpened = false // Change the variable value after 1 second\n    console.log('Variable value changed to true after 1 second')\n  }, 1000) // 1000 milliseconds (1 second)\n}\n\nconst getURLFromAnnotationID = function (id) {\n  let url\n  if (window.cag.annotations.length > 0) {\n    const annotation = window.cag.annotations.find((anno) => {\n      return anno.id === id\n    })\n    url = annotation.target[0].source + '#' + Config.urlParamName + ':' + annotation.id\n  }\n  return url\n}\n\nwindow.onload = kudeatzaileakHasieratu\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/scripts/cmapCloudPage.js b/app/scripts/cmapCloudPage.js
--- a/app/scripts/cmapCloudPage.js	(revision 356f155a8605a6ee982a9eda44ad60c00d912852)
+++ b/app/scripts/cmapCloudPage.js	(date 1696949322389)
@@ -203,7 +203,7 @@
       if (_.isString(dimensionString)) {
         let urlList
         if (urlInput && _.isString(urlInput)) {
-          urlList = urlInput.split(';')
+          urlList = urlInput.split(';').filter(Boolean)
           urlList.forEach(element => element.trim)
         }
         const dimensionsList = dimensionString.split(';')
Index: app/scripts/importExport/cmap/cmapCloud/ExportCmapCloud.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import CmapCloudClient from './CmapCloudClient'\nimport _ from 'lodash'\nimport Alerts from '../../../utils/Alerts'\nimport AnnotationUtils from '../../../utils/AnnotationUtils'\nimport LanguageUtils from '../../../utils/LanguageUtils'\nimport FileSaver from 'file-saver'\nimport Config from '../../../Config'\nimport jsYaml from 'js-yaml'\n\nclass ExportCmapCloud {\n  static export (xmlDoc, urlFiles, userData, dimensions, mappingAnnotation) {\n    const user = userData.user\n    const pass = userData.password\n    const uid = userData.uid\n    const cmapCloudClient = new CmapCloudClient(user, pass, uid)\n    if (mappingAnnotation) {\n      this.exportToExistingFolder(cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, mappingAnnotation)\n    } else {\n      this.exportWithVersions(cmapCloudClient, xmlDoc, urlFiles, userData)\n    }\n  }\n\n  static exportFirstMap (name, xmlDoc, userData, group, dimensionsString) {\n    const user = userData.user\n    const pass = userData.password\n    const uid = userData.uid\n    const cmapCloudClient = new CmapCloudClient(user, pass, uid)\n    cmapCloudClient.getRootFolderInfor((data) => {\n      cmapCloudClient.createFolder(name, (newFolderData) => {\n        const folderID = this.getFolderID(newFolderData)\n        // Add resource-group-list\n        const mapString = new XMLSerializer().serializeToString(xmlDoc)\n        cmapCloudClient.uploadMap(folderID, mapString, (data) => {\n          console.log(data)\n          const urlWithIdentifier = data.childNodes[0].childNodes[5].innerHTML\n          const pattern = /id=([\\w-]+)/\n          const match = urlWithIdentifier.match(pattern)\n          // Check if a match was found and extract the desired string\n          if (match) {\n            const mapId = match[1]\n            console.log(mapId)\n            let annotationServer\n            if (window.cag) {\n              annotationServer = window.cag.annotationServerManager\n            } else {\n              annotationServer = window.abwa.annotationServerManager\n            }\n            const annotation = this.createMappingAnnotation(folderID, mapId, group)\n            annotationServer.client.createNewAnnotation(annotation, (err, newAnnotation) => {\n              if (err) {\n                Alerts.errorAlert({ text: 'Unexpected error, unable to create annotation' })\n              } else {\n                if (window.location.href.startsWith('https://cmapcloud.ihmc.us/cmaps')) {\n                  window.location.reload()\n                }\n                Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\\n', title: 'Completed' })\n              }\n            })\n          } else {\n            console.log('No match found')\n          }\n        }, group, dimensionsString)\n        // FileSaver.saveAs(blob, LanguageUtils.camelize(folderName) + '(' + window.abwa.groupSelector.currentGroup.id + ')' + '.cxl')\n        // })\n      }, reason => {\n      })\n    })\n  }\n\n  static exportWithVersions (cmapCloudClient, xmlDoc, urlFiles) {\n    cmapCloudClient.getRootFolderInfor((data) => {\n      const folderName = this.getFolderName(data)\n      cmapCloudClient.createFolder(folderName, (newFolderData) => {\n        const folderId = this.getFolderID(newFolderData)\n        this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, folderName)\n      })\n    })\n  }\n\n  static exportToExistingFolder (cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, mappingAnnotation) {\n    const folderId = AnnotationUtils.getFolderIDFromAnnotation(mappingAnnotation)\n    console.log(folderId)\n    this.removeFolderResources(cmapCloudClient, folderId, () => {\n      chrome.runtime.sendMessage({ scope: 'cmapCloud', cmd: 'getFolderList', data: folderId }, (response) => {\n        if (response.info) {\n          const parser = new DOMParser()\n          const answer = parser.parseFromString(response.info, 'text/xml')\n          console.log(answer)\n          const list = answer.querySelector('res-meta-list')\n          let identifiers = []\n          Array.from(list.children).forEach(item => {\n            Array.from(item.children).forEach(tag => {\n              if (tag.nodeName === 'dc:identifier') {\n                identifiers.push(tag)\n              }\n            })\n          })\n          const pattern = /id=([\\w-]+)/\n          identifiers = identifiers.map(identifier => {\n            const match = identifier.innerHTML.match(pattern)\n            // Check if a match was found and extract the desired string\n            if (match) {\n              return match[1]\n            } else {\n              return null\n            }\n          })\n          console.log(identifiers)\n          if (identifiers.length > 0) {\n            Alerts.infoAlert({ text: 'Folder is not empty', title: 'Error' })\n          } else {\n            this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions)\n          }\n        }\n      })\n    })\n  }\n\n  static uploadAll (cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions, folderName) {\n    const beginPromises = []\n    for (let i = 0; i < urlFiles.length; i++) {\n      const urlFile = urlFiles[i]\n      const beginPromise = new Promise((resolve, reject) => {\n        cmapCloudClient.uploadWebResource(folderId, urlFile, (data) => {\n          resolve(data)\n        })\n      })\n      beginPromises.push(beginPromise)\n    }\n    Promise.all(beginPromises).then(createdResources => {\n      // Results\n      const createdResourcesID = _.map(createdResources, (res) => {\n        const retrieve = res.all[3].innerHTML.match(/id=[\\s\\S]*.url/)[0]\n        const resourceIDName = retrieve.replace('.url', '').replace('id=', '')\n        return resourceIDName\n      })\n      for (let j = 0; j < createdResourcesID.length; j++) {\n        const id = createdResourcesID[j].split('/')[0]\n        let name = createdResourcesID[j].split('/')[1]\n        name = decodeURIComponent(name)\n        const urlFile = _.find(urlFiles, (file) => {\n          return file.name === name\n        })\n        if (urlFile) {\n          urlFile.id = id\n        }\n      }\n      // Add resource-group-list\n      this.referenceURLIntoMap(xmlDoc, urlFiles, folderId)\n      const mapString = new XMLSerializer().serializeToString(xmlDoc)\n      const blob = new window.Blob([mapString], {\n        type: 'text/plain;charset=utf-8'\n      })\n      let name\n      folderName ? name = folderName : name = window.abwa.groupSelector.currentGroup.name\n      FileSaver.saveAs(blob, LanguageUtils.camelize(window.abwa.groupSelector.currentGroup.name) + '(' + window.abwa.groupSelector.currentGroup.id + ')' + '.cxl')\n      Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\\n Please move the downloaded map to the corresponding CmapCloud folder.', title: 'Completed' })\n      /* cmapCloudClient.uploadMap(folderId, mapString, (data) => {\n        console.log(data)\n        Alerts.infoAlert({ text: 'You have available your resource in CmapCloud ' + name + ' folder.' })\n      }, window.abwa.groupSelector.currentGroup, dimensions)\n      // }) */\n    }, reason => {\n    })\n  }\n\n  static getFolderID (data) {\n    const identifier = data.getElementsByTagName('dc:identifier')[0].innerHTML.match(/id=(\\w+)-(\\w+)-(\\w+)/)[0]\n    const folderID = identifier.toString().replace('id=', '')\n    return folderID\n  }\n\n  static referenceURLIntoMap (xmlDoc, urlFiles, folderID) {\n    const resourceGroupListElement = xmlDoc.getElementsByTagName('resource-group-list')[0]\n    const resourcesMap = _.chain(urlFiles)\n      .groupBy('parentId')\n      .toPairs()\n      .map(pair => _.zipObject(['parentId', 'urls'], pair))\n      .value()\n    for (let i = 0; i < resourcesMap.length; i++) {\n      const resource = resourcesMap[i]\n      const resourceGroupElement = xmlDoc.createElement('resource-group')\n      const resourceGroupIdAttribute = document.createAttribute('parent-id')\n      resourceGroupIdAttribute.value = resource.parentId\n      resourceGroupElement.setAttributeNode(resourceGroupIdAttribute)\n      const groupTypeIdAttribute = document.createAttribute('group-type')\n      groupTypeIdAttribute.value = 'text-and-image'\n      resourceGroupElement.setAttributeNode(groupTypeIdAttribute)\n      for (let j = 0; j < resource.urls.length; j++) {\n        const url = resource.urls[j]\n        const resourceElement = xmlDoc.createElement('resource')\n        const resourceElementLabelAttribute = document.createAttribute('label')\n        resourceElementLabelAttribute.value = url.name\n        resourceElement.setAttributeNode(resourceElementLabelAttribute)\n        const resourceElementNameAttribute = document.createAttribute('resource-name')\n        resourceElementNameAttribute.value = url.name\n        resourceElement.setAttributeNode(resourceElementNameAttribute)\n        const resourceElementURLAttribute = document.createAttribute('resource-url')\n        resourceElementURLAttribute.value = 'https://cmapscloud.ihmc.us:443/id=' + url.id + '/' + url.name + '.url?redirect'\n        resourceElement.setAttributeNode(resourceElementURLAttribute)\n        const resourceElementIdAttribute = document.createAttribute('resource-id')\n        resourceElementIdAttribute.value = url.id\n        resourceElement.setAttributeNode(resourceElementIdAttribute)\n        const resourceFolderIdAttribute = document.createAttribute('resource-folder-id')\n        resourceFolderIdAttribute.value = folderID\n        resourceElement.setAttributeNode(resourceFolderIdAttribute)\n        const resourceServerIdAttribute = document.createAttribute('resource-server-id')\n        resourceServerIdAttribute.value = '1MHZH5RK6-2C8DRLF-1'\n        resourceElement.setAttributeNode(resourceServerIdAttribute)\n        const resourceElementMimetypeAttribute = document.createAttribute('resource-mimetype')\n        resourceElementMimetypeAttribute.value = 'text/x-url'\n        resourceElement.setAttributeNode(resourceElementMimetypeAttribute)\n        resourceGroupElement.appendChild(resourceElement)\n      }\n      resourceGroupListElement.appendChild(resourceGroupElement)\n    }\n    const mapString = new XMLSerializer().serializeToString(xmlDoc)\n    return mapString\n  }\n\n  static getFolderName (data) {\n    let folderName\n    const elements = data.getElementsByTagName('res-meta')\n    if (elements.length > 0) {\n      const folderElements = _.map(_.filter(elements, (element) => {\n        if (element.attributes.format) {\n          return element.attributes.format.nodeValue === 'x-nlk-project/x-binary'\n        }\n      }), (folderElement) => {\n        return folderElement.attributes.title.nodeValue\n      })\n      let candidateName\n      let foundFolder\n      let i = 1\n      while (true) {\n        candidateName = window.abwa.groupSelector.currentGroup.name + '_v.' + i\n        foundFolder = _.filter(folderElements, (folderName) => {\n          return folderName === candidateName\n        })\n        if (foundFolder.length === 0) {\n          return candidateName\n        } else {\n          i++\n        }\n      }\n    } else {\n      folderName = window.abwa.groupSelector.currentGroup.name + '_v.1'\n      return folderName\n    }\n  }\n\n  static createMappingAnnotation (folderId, mapId, group) {\n    const motivationTag = 'motivation:mapping'\n    const folderTag = Config.namespace + ':folder:' + folderId\n    const mapTag = Config.namespace + ':map:' + mapId\n\n    const tags = [motivationTag, folderTag, mapTag]\n    // Construct text attribute of the annotation\n    let textObject\n    // Return the constructed annotation\n    return {\n      name: 'mappingAnnotation',\n      group: group.id,\n      permissions: {\n        read: ['group:' + group.id]\n      },\n      references: [],\n      motivation: 'mapping',\n      tags: tags,\n      target: [],\n      text: jsYaml.dump(textObject),\n      uri: 'https://hypothes.is/groups/' + group.id\n    }\n  }\n\n  static removeFolderResources (cmapCloudClient, folderId, callback) {\n    chrome.runtime.sendMessage({ scope: 'cmapCloud', cmd: 'getFolderList', data: folderId }, (response) => {\n      if (response.info) {\n        const parser = new DOMParser()\n        const xmlDoc = parser.parseFromString(response.info, 'text/xml')\n        console.log(xmlDoc)\n        const list = xmlDoc.querySelector('res-meta-list')\n        let identifiers = []\n        Array.from(list.children).forEach(item => {\n          Array.from(item.children).forEach(tag => {\n            if (tag.nodeName === 'dc:identifier') {\n              identifiers.push(tag)\n            }\n          })\n        })\n        const pattern = /id=([\\w-]+)/\n        if (identifiers) {\n          identifiers = identifiers.map(identifier => {\n            const match = identifier.innerHTML.match(pattern)\n            // Check if a match was found and extract the desired string\n            if (match) {\n              return match[1]\n            } else {\n              return null\n            }\n          })\n          console.log(identifiers)\n          const beginDeletePromises = []\n          for (let i = 0; i < identifiers.length; i++) {\n            const identifier = identifiers[i]\n            const beginPromise = new Promise((resolve, reject) => {\n              cmapCloudClient.removeResource(identifier, (data) => {\n                resolve(data)\n              })\n            })\n            beginDeletePromises.push(beginPromise)\n          }\n          Promise.all(beginDeletePromises).then(deletedResources => {\n            console.log(deletedResources)\n            if (_.isFunction(callback)) {\n              callback()\n            }\n          }, reason => {\n          })\n        } else {\n          if (_.isFunction(callback)) {\n            callback()\n          }\n        }\n      } else {\n        Alerts.infoAlert({ text: 'Folder not found', title: 'Info' })\n      }\n    })\n  }\n}\n\nexport default ExportCmapCloud\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/scripts/importExport/cmap/cmapCloud/ExportCmapCloud.js b/app/scripts/importExport/cmap/cmapCloud/ExportCmapCloud.js
--- a/app/scripts/importExport/cmap/cmapCloud/ExportCmapCloud.js	(revision 356f155a8605a6ee982a9eda44ad60c00d912852)
+++ b/app/scripts/importExport/cmap/cmapCloud/ExportCmapCloud.js	(date 1696952764607)
@@ -6,80 +6,59 @@
 import FileSaver from 'file-saver'
 import Config from '../../../Config'
 import jsYaml from 'js-yaml'
+import ToolURL from '../evidenceAnnotation/ToolURL'
 
 class ExportCmapCloud {
-  static export (xmlDoc, urlFiles, userData, dimensions, mappingAnnotation) {
+  static export (xmlDoc, urlFiles, userData, dimensions, urlString, mappingAnnotation) {
     const user = userData.user
     const pass = userData.password
     const uid = userData.uid
     const cmapCloudClient = new CmapCloudClient(user, pass, uid)
     if (mappingAnnotation) {
-      this.exportToExistingFolder(cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, mappingAnnotation)
-    } else {
-      this.exportWithVersions(cmapCloudClient, xmlDoc, urlFiles, userData)
+      this.exportToExistingFolder(cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, urlString, mappingAnnotation)
     }
   }
 
-  static exportFirstMap (name, xmlDoc, userData, group, dimensionsString) {
+  static exportFirstMap (name, xmlDoc, userData, group, dimensionsString, urlString, codebook) {
     const user = userData.user
     const pass = userData.password
     const uid = userData.uid
     const cmapCloudClient = new CmapCloudClient(user, pass, uid)
+    const urlList = urlString.split(';').filter(Boolean)
+    const themes = codebook.themes
+    const topic = _.find(themes, (theme) => { return theme.isTopic === true })
+    const elementID = topic.id
+    const urlFiles = []
+    for (let i = 0; i < urlList.length; i++) {
+      const direction = urlList[i]
+      let name = direction
+      name = name.replace(/[^a-zA-Z0-9 ]/g, '').replace(/\s/g, '')
+      const newUrl = new ToolURL({ elementID, name, direction })
+      urlFiles.push(newUrl)
+    }
     cmapCloudClient.getRootFolderInfor((data) => {
       cmapCloudClient.createFolder(name, (newFolderData) => {
         const folderID = this.getFolderID(newFolderData)
         // Add resource-group-list
-        const mapString = new XMLSerializer().serializeToString(xmlDoc)
-        cmapCloudClient.uploadMap(folderID, mapString, (data) => {
-          console.log(data)
-          const urlWithIdentifier = data.childNodes[0].childNodes[5].innerHTML
-          const pattern = /id=([\w-]+)/
-          const match = urlWithIdentifier.match(pattern)
-          // Check if a match was found and extract the desired string
-          if (match) {
-            const mapId = match[1]
-            console.log(mapId)
-            let annotationServer
-            if (window.cag) {
-              annotationServer = window.cag.annotationServerManager
-            } else {
-              annotationServer = window.abwa.annotationServerManager
-            }
-            const annotation = this.createMappingAnnotation(folderID, mapId, group)
-            annotationServer.client.createNewAnnotation(annotation, (err, newAnnotation) => {
-              if (err) {
-                Alerts.errorAlert({ text: 'Unexpected error, unable to create annotation' })
-              } else {
-                if (window.location.href.startsWith('https://cmapcloud.ihmc.us/cmaps')) {
-                  window.location.reload()
-                }
-                Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\n', title: 'Completed' })
-              }
-            })
-          } else {
-            console.log('No match found')
-          }
-        }, group, dimensionsString)
-        // FileSaver.saveAs(blob, LanguageUtils.camelize(folderName) + '(' + window.abwa.groupSelector.currentGroup.id + ')' + '.cxl')
-        // })
+        // const mapString = new XMLSerializer().serializeToString(xmlDoc)
+        this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderID, dimensionsString, name, true, group)
       }, reason => {
       })
     })
   }
 
-  static exportWithVersions (cmapCloudClient, xmlDoc, urlFiles) {
-    cmapCloudClient.getRootFolderInfor((data) => {
-      const folderName = this.getFolderName(data)
-      cmapCloudClient.createFolder(folderName, (newFolderData) => {
-        const folderId = this.getFolderID(newFolderData)
-        this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, folderName)
-      })
-    })
-  }
-
-  static exportToExistingFolder (cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, mappingAnnotation) {
+  static exportToExistingFolder (cmapCloudClient, xmlDoc, urlFiles, userData, dimensions, urlString, mappingAnnotation) {
+    const urlList = urlString.split(';').filter(Boolean)
+    const topic = window.abwa.codebookManager.codebookReader.getTopicTheme()
+    const elementID = topic.id
+    for (let i = 0; i < urlList.length; i++) {
+      const direction = urlList[i]
+      let name = direction
+      name = name.replace(/[^a-zA-Z0-9 ]/g, '').replace(/\s/g, '')
+      const newUrl = new ToolURL({ elementID, name, direction })
+      urlFiles.push(newUrl)
+    }
     const folderId = AnnotationUtils.getFolderIDFromAnnotation(mappingAnnotation)
-    console.log(folderId)
     this.removeFolderResources(cmapCloudClient, folderId, () => {
       chrome.runtime.sendMessage({ scope: 'cmapCloud', cmd: 'getFolderList', data: folderId }, (response) => {
         if (response.info) {
@@ -109,14 +88,14 @@
           if (identifiers.length > 0) {
             Alerts.infoAlert({ text: 'Folder is not empty', title: 'Error' })
           } else {
-            this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions)
+            this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions, null, false)
           }
         }
       })
     })
   }
 
-  static uploadAll (cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions, folderName) {
+  static uploadAll (cmapCloudClient, xmlDoc, urlFiles, folderId, dimensions, folderName, uploadMap, group) {
     const beginPromises = []
     for (let i = 0; i < urlFiles.length; i++) {
       const urlFile = urlFiles[i]
@@ -153,13 +132,41 @@
       })
       let name
       folderName ? name = folderName : name = window.abwa.groupSelector.currentGroup.name
-      FileSaver.saveAs(blob, LanguageUtils.camelize(window.abwa.groupSelector.currentGroup.name) + '(' + window.abwa.groupSelector.currentGroup.id + ')' + '.cxl')
-      Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\n Please move the downloaded map to the corresponding CmapCloud folder.', title: 'Completed' })
-      /* cmapCloudClient.uploadMap(folderId, mapString, (data) => {
-        console.log(data)
-        Alerts.infoAlert({ text: 'You have available your resource in CmapCloud ' + name + ' folder.' })
-      }, window.abwa.groupSelector.currentGroup, dimensions)
-      // }) */
+      if (uploadMap) {
+        cmapCloudClient.uploadMap(folderId, mapString, (data) => {
+          console.log(data)
+          const urlWithIdentifier = data.childNodes[0].childNodes[5].innerHTML
+          const pattern = /id=([\w-]+)/
+          const match = urlWithIdentifier.match(pattern)
+          // Check if a match was found and extract the desired string
+          if (match) {
+            const mapId = match[1]
+            console.log(mapId)
+            let annotationServer
+            if (window.cag) {
+              annotationServer = window.cag.annotationServerManager
+            } else {
+              annotationServer = window.abwa.annotationServerManager
+            }
+            const annotation = this.createMappingAnnotation(folderId, mapId, group)
+            annotationServer.client.createNewAnnotation(annotation, (err, newAnnotation) => {
+              if (err) {
+                Alerts.errorAlert({ text: 'Unexpected error, unable to create annotation' })
+              } else {
+                if (window.location.href.startsWith('https://cmapcloud.ihmc.us/cmaps')) {
+                  window.location.reload()
+                }
+                Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\n', title: 'Completed' })
+              }
+            })
+          } else {
+            console.log('No match found')
+          }
+        }, group, dimensions)
+      } else {
+        FileSaver.saveAs(blob, LanguageUtils.camelize(window.abwa.groupSelector.currentGroup.name) + '(' + window.abwa.groupSelector.currentGroup.id + ')' + '.cxl')
+        Alerts.infoAlert({ text: 'You have available your resource in CmapCloud in ' + name + ' folder.\n Please move the downloaded map to the corresponding CmapCloud folder.', title: 'Completed' })
+      }
     }, reason => {
     })
   }
@@ -327,6 +334,16 @@
       }
     })
   }
+
+  static exportWithVersions (cmapCloudClient, xmlDoc, urlFiles) {
+    cmapCloudClient.getRootFolderInfor((data) => {
+      const folderName = this.getFolderName(data)
+      cmapCloudClient.createFolder(folderName, (newFolderData) => {
+        const folderId = this.getFolderID(newFolderData)
+        this.uploadAll(cmapCloudClient, xmlDoc, urlFiles, folderId, folderName)
+      })
+    })
+  }
 }
 
 export default ExportCmapCloud
Index: app/scripts/importExport/cmap/evidenceAnnotation/ToolURL.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import URL from './URL'\nimport Config from '../../../Config'\n\nclass ToolURL extends URL {\n  constructor ({ elementID, name, annotation }) {\n    super({ elementID, name, annotation })\n    this.direction = annotation.target[0].source.url + '#' + Config.urlParamName + ':' + annotation.id\n    this.content = '[InternetShortcut]\\n' +\n      'URL=' + this.direction\n  }\n}\n\nexport default ToolURL\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/scripts/importExport/cmap/evidenceAnnotation/ToolURL.js b/app/scripts/importExport/cmap/evidenceAnnotation/ToolURL.js
--- a/app/scripts/importExport/cmap/evidenceAnnotation/ToolURL.js	(revision 356f155a8605a6ee982a9eda44ad60c00d912852)
+++ b/app/scripts/importExport/cmap/evidenceAnnotation/ToolURL.js	(date 1696949322385)
@@ -2,9 +2,13 @@
 import Config from '../../../Config'
 
 class ToolURL extends URL {
-  constructor ({ elementID, name, annotation }) {
-    super({ elementID, name, annotation })
-    this.direction = annotation.target[0].source.url + '#' + Config.urlParamName + ':' + annotation.id
+  constructor ({ elementID, name, annotation, direction }) {
+    super({ elementID, name, annotation, direction })
+    if (direction) {
+      this.direction = direction
+    } else {
+      this.direction = annotation.target[0].source.url + '#' + Config.urlParamName + ':' + annotation.id
+    }
     this.content = '[InternetShortcut]\n' +
       'URL=' + this.direction
   }
Index: app/scripts/importExport/cmap/evidenceAnnotation/URL.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class URL {\n  constructor ({ elementID, name, annotation }) {\n    this.id = ''\n    this.parentId = elementID\n    this.name = name.replace('&', 'And')\n    this.direction = annotation.target[0].source.url\n    this.content = '[InternetShortcut]\\n' +\n      'URL=' + this.direction\n  }\n}\n\nexport default URL\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/scripts/importExport/cmap/evidenceAnnotation/URL.js b/app/scripts/importExport/cmap/evidenceAnnotation/URL.js
--- a/app/scripts/importExport/cmap/evidenceAnnotation/URL.js	(revision 356f155a8605a6ee982a9eda44ad60c00d912852)
+++ b/app/scripts/importExport/cmap/evidenceAnnotation/URL.js	(date 1696949322382)
@@ -1,9 +1,13 @@
 class URL {
-  constructor ({ elementID, name, annotation }) {
+  constructor ({ elementID, name, annotation, direction }) {
     this.id = ''
     this.parentId = elementID
     this.name = name.replace('&', 'And')
-    this.direction = annotation.target[0].source.url
+    if (direction) {
+      this.direction = direction
+    } else {
+      this.direction = annotation.target[0].source.url
+    }
     this.content = '[InternetShortcut]\n' +
       'URL=' + this.direction
   }
Index: app/scripts/importExport/cmap/CXLExporter.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import ExportCXLArchiveFile from './ExportCXLArchiveFile'\nimport ExportCmapCloud from './cmapCloud/ExportCmapCloud'\nimport ToolURL from './evidenceAnnotation/ToolURL'\nimport LanguageUtils from '../../utils/LanguageUtils'\nimport _ from 'lodash'\nimport ColorUtils from '../../utils/ColorUtils'\nimport Config from '../../Config'\n\nexport class LinkingPhrase {\n  constructor (linkingWord, id) {\n    // code\n    this.linkingWord = linkingWord\n    this.id = id\n    this.fromConcepts = []\n    this.toConcepts = []\n    this.evidenceAnnotations = []\n  }\n}\n\nexport class CXLExporter {\n  static exportCXLFile (exportType, userData, mappingAnnotation) {\n    // Get annotations from tag manager and content annotator\n    const concepts = window.abwa.mapContentManager.concepts\n    const relationships = window.abwa.mapContentManager.relationships\n    // Prepare linking phrases for doing conections\n    const linkingPhrases = []\n    // linkingPhrases = this.mergeLinkingPhrases(linkingPhrases, relationships)\n    for (let i = 0; i < relationships.length; i++) {\n      const relation = relationships[i]\n      const linkingPhraseToAdd = new LinkingPhrase(relation.linkingWord, relation.id)\n      if (relation.fromConcept && relation.toConcept) {\n        linkingPhraseToAdd.fromConcepts.push(relation.fromConcept.id)\n        linkingPhraseToAdd.toConcepts.push(relation.toConcept.id)\n        linkingPhraseToAdd.evidenceAnnotations = linkingPhraseToAdd.evidenceAnnotations.concat(relation.evidenceAnnotations)\n        linkingPhrases.push(linkingPhraseToAdd)\n      }\n    }\n    const urlFiles = []\n    const xmlDoc = document.implementation.createDocument(null, 'cmap', null)\n    const cmapElement = xmlDoc.firstChild\n\n    // Create map xmlns:dcterms attribute\n    const att = document.createAttribute('xmlns:dcterms')\n    att.value = 'http://purl.org/dc/terms/'\n    cmapElement.setAttributeNode(att)\n\n    // Create map xmlns attribute\n    const att1 = document.createAttribute('xmlns')\n    att1.value = 'http://cmap.ihmc.us/xml/cmap/'\n    cmapElement.setAttributeNode(att1)\n\n    // Create map xmlns:dc attribute\n    const att2 = document.createAttribute('xmlns:dc')\n    att2.value = 'http://purl.org/dc/elements/1.1/'\n    cmapElement.setAttributeNode(att2)\n\n    // Create map xmlns:vcard attribute\n    const att3 = document.createAttribute('xmlns:vcard')\n    att3.value = 'http://www.w3.org/2001/vcard-rdf/3.0#'\n    cmapElement.setAttributeNode(att3)\n\n    // Create metadata\n    const metadata = xmlDoc.createElement('res-meta')\n    cmapElement.appendChild(metadata)\n\n    // Set title\n    const title = xmlDoc.createElement('dc:title')\n    title.textContent = LanguageUtils.camelize(window.abwa.groupSelector.currentGroup.name) + '(' + window.abwa.groupSelector.currentGroup.id + ')'\n    metadata.appendChild(title)\n\n    // Set focus question\n    const focusQuestion = xmlDoc.createElement('dc:description')\n    const topicTheme = window.abwa.codebookManager.codebookReader.getTopicTheme()\n    if (topicTheme.topic !== '') {\n      focusQuestion.textContent = topicTheme.topic\n    } else {\n      focusQuestion.textContent = topicTheme.name\n    }\n    metadata.appendChild(focusQuestion)\n\n    // Set keywords\n    const dimensionsTag = xmlDoc.createElement('dc:subject')\n    dimensionsTag.textContent = window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud()\n    metadata.appendChild(dimensionsTag)\n\n    // Set keywords\n    const urlsTag = xmlDoc.createElement('dc:language')\n    const urlString = window.abwa.codebookManager.codebookReader.codebook.readingMaterials\n    urlsTag.textContent = urlString\n    metadata.appendChild(urlsTag)\n\n    // Set Hypothes.is group\n    const rights = xmlDoc.createElement('dcterms:rightsHolder')\n    const creator = xmlDoc.createElement('dc:creator')\n    const contributor = xmlDoc.createElement('dc:contributor')\n    const groupId = xmlDoc.createElement('vcard:FN')\n    groupId.textContent = window.abwa.groupSelector.currentGroup.id\n    rights.appendChild(groupId)\n    creator.appendChild(groupId)\n    contributor.appendChild(groupId)\n    metadata.appendChild(rights)\n    metadata.appendChild(creator)\n    metadata.appendChild(contributor)\n\n    // Create map\n    const map = xmlDoc.createElement('map')\n    cmapElement.appendChild(map)\n\n    // Concept list\n    const conceptList = xmlDoc.createElement('concept-list')\n    map.appendChild(conceptList)\n\n    // linking phrase list\n    const linkingPhraseList = xmlDoc.createElement('linking-phrase-list')\n    map.appendChild(linkingPhraseList)\n\n    // connection list\n    const connectionList = xmlDoc.createElement('connection-list')\n    map.appendChild(connectionList)\n    // resource-group-list\n    const resourceGroupList = xmlDoc.createElement('resource-group-list')\n    map.appendChild(resourceGroupList)\n    // concept appearance list\n    const conceptAppearanceList = xmlDoc.createElement('concept-appearance-list')\n    map.appendChild(conceptAppearanceList)\n\n    // linking appearance list\n    const linkingAppearanceList = xmlDoc.createElement('linking-phrase-appearance-list')\n    map.appendChild(linkingAppearanceList)\n\n    // connection appearance list\n    const connectionAppearanceList = xmlDoc.createElement('connection-appearance-list')\n    map.appendChild(connectionAppearanceList)\n    // styleSheetList\n    const styleSheetList = xmlDoc.createElement('style-sheet-list')\n\n    const styleSheetDefault = xmlDoc.createElement('style-sheet')\n    const styleSheetIdDefault = document.createAttribute('id')\n    styleSheetIdDefault.value = '_Default_'\n    styleSheetDefault.setAttributeNode(styleSheetIdDefault)\n\n    const mapStyle = xmlDoc.createElement('map-style')\n    const mapStyleBackgroundColor = document.createAttribute('background-color')\n    mapStyleBackgroundColor.value = '255,255,255,255'\n    mapStyle.setAttributeNode(mapStyleBackgroundColor)\n    styleSheetDefault.appendChild(mapStyle)\n\n    const styleSheetLatest = xmlDoc.createElement('style-sheet')\n    const styleSheetIdLatest = document.createAttribute('id')\n    styleSheetIdLatest.value = '_LatestChanges_'\n    styleSheetLatest.setAttributeNode(styleSheetIdLatest)\n\n    styleSheetList.appendChild(styleSheetDefault)\n    styleSheetList.appendChild(styleSheetLatest)\n    map.appendChild(styleSheetList)\n\n    // Add meta-concepts\n    const dimensions = window.abwa.codebookManager.codebookReader.codebook.dimensions\n    for (let i = 0; i < dimensions.length; i++) {\n      const dimension = dimensions[i]\n      const dimensionElement = xmlDoc.createElement('concept')\n      let id = document.createAttribute('id')\n      id.value = dimension.id\n      dimensionElement.setAttributeNode(id)\n      const label = document.createAttribute('label')\n      label.value = dimension.name\n      dimensionElement.setAttributeNode(label)\n      conceptList.appendChild(dimensionElement)\n      const dimensionAppearance = xmlDoc.createElement('concept-appearance')\n      id = document.createAttribute('id')\n      const elementID = dimension.id\n      id.value = elementID\n      dimensionAppearance.setAttributeNode(id)\n      const background = document.createAttribute('background-color')\n      background.value = ColorUtils.turnForCmapCloud(dimension.color)\n      dimensionAppearance.setAttributeNode(background)\n      const font = document.createAttribute('font-style')\n      font.value = 'italic|bold'\n      dimensionAppearance.setAttributeNode(font)\n      const border = document.createAttribute('border-style')\n      border.value = 'dashed'\n      dimensionAppearance.setAttributeNode(border)\n      const fontSize = document.createAttribute('font-size')\n      fontSize.value = '18'\n      dimensionAppearance.setAttributeNode(fontSize)\n      conceptAppearanceList.appendChild(dimensionAppearance)\n    }\n    // Add concepts\n    for (let i = 0; i < concepts.length; i++) {\n      const concept = concepts[i]\n      const conceptElement = xmlDoc.createElement('concept')\n      let id = document.createAttribute('id')\n      id.value = concept.theme.id\n      conceptElement.setAttributeNode(id)\n      const label = document.createAttribute('label')\n      if (concept.theme.topic !== '') {\n        label.value = concept.theme.topic\n      } else {\n        label.value = concept.theme.name\n      }\n      conceptElement.setAttributeNode(label)\n      conceptList.appendChild(conceptElement)\n      const conceptAppearance = xmlDoc.createElement('concept-appearance')\n      id = document.createAttribute('id')\n      const elementID = concept.theme.id\n      id.value = elementID\n      conceptAppearance.setAttributeNode(id)\n      const background = document.createAttribute('background-color')\n      if (concept.theme.isTopic) {\n        background.value = ColorUtils.turnForCmapCloud(ColorUtils.getTopicColor())\n        conceptAppearance.setAttributeNode(background)\n      } else {\n        const dimension = window.abwa.codebookManager.codebookReader.codebook.getDimensionByName(concept.theme.dimension)\n        if (dimension) {\n          background.value = ColorUtils.turnForCmapCloud(dimension.color)\n          conceptAppearance.setAttributeNode(background)\n        }\n      }\n      // font-size=\"14\"\n      const fontSize = document.createAttribute('font-size')\n      fontSize.value = '14'\n      conceptAppearance.setAttributeNode(fontSize)\n      conceptAppearanceList.appendChild(conceptAppearance)\n      if (concept.evidenceAnnotations.length > 0) {\n        for (let i = 0; i < concept.evidenceAnnotations.length; i++) {\n          const annotation = concept.evidenceAnnotations[i]\n          let name\n          if (i === 0) {\n            name = LanguageUtils.camelize(concept.theme.name)\n          } else {\n            name = LanguageUtils.camelize(concept.theme.name)\n          }\n          name = name.replace(/[^a-zA-Z0-9 ]/g, '').replace(/\\s/g, '') + '---' + annotation.id\n          const url = new ToolURL({ elementID, name, annotation })\n          urlFiles.push(url)\n        }\n      }\n    }\n\n    // Add linking phrase\n    let connectionID = 1\n    for (let i = 0; i < linkingPhrases.length; i++) {\n      // Linking phrase\n      const linkingPhrase = linkingPhrases[i]\n      const linkingElement = xmlDoc.createElement('linking-phrase')\n      let id = document.createAttribute('id')\n      const elementID = linkingPhrase.id\n      id.value = elementID\n      linkingElement.setAttributeNode(id)\n      const label = document.createAttribute('label')\n      label.value = linkingPhrase.linkingWord\n      linkingElement.setAttributeNode(label)\n      linkingPhraseList.appendChild(linkingElement)\n      const linkingAppearance = xmlDoc.createElement('linking-phrase-appearance')\n      id = document.createAttribute('id')\n      id.value = linkingPhrase.id\n      linkingAppearance.setAttributeNode(id)\n      linkingAppearanceList.appendChild(linkingAppearance)\n      if (linkingPhrase.evidenceAnnotations.length > 0) {\n        for (let j = 0; j < linkingPhrase.evidenceAnnotations.length; j++) {\n          const annotation = linkingPhrase.evidenceAnnotations[j]\n          if (annotation.target) {\n            if (annotation.target.length > 0) {\n              let name\n              const fromName = annotation.tags[0].replace('from:', '')\n              const toName = annotation.tags[2].replace('to:', '')\n              if (i === 0) {\n                name = LanguageUtils.camelize(fromName) + '->' + LanguageUtils.camelize(linkingPhrase.linkingWord) + '->' + LanguageUtils.camelize(toName)\n              } else {\n                name = LanguageUtils.camelize(fromName) + '->' + LanguageUtils.camelize(linkingPhrase.linkingWord) + '->' + LanguageUtils.camelize(toName)\n              }\n              name = name.replace(/[^a-zA-Z0-9-> ]/g, '').replace(/\\s/g, '') + '---' + annotation.id\n              const url = new ToolURL({ elementID, name, annotation })\n              urlFiles.push(url)\n            }\n          }\n        }\n      }\n      // Connection\n      // From\n      for (let i = 0; i < linkingPhrase.fromConcepts.length; i++) {\n        const fromConceptID = linkingPhrase.fromConcepts[i]\n        const connectionElement = xmlDoc.createElement('connection')\n        id = document.createAttribute('id')\n        id.value = connectionID.toString()\n        connectionElement.setAttributeNode(id)\n        const fromID = document.createAttribute('from-id')\n        fromID.value = fromConceptID\n        connectionElement.setAttributeNode(fromID)\n        const toID = document.createAttribute('to-id')\n        toID.value = linkingPhrase.id\n        connectionElement.setAttributeNode(toID)\n        connectionList.appendChild(connectionElement)\n        const connectionAppearanceElement = xmlDoc.createElement('connection-appearance')\n        id = document.createAttribute('id')\n        id.value = connectionID.toString()\n        connectionAppearanceElement.setAttributeNode(id)\n        const fromPos = document.createAttribute('from-pos')\n        fromPos.value = 'center'\n        connectionAppearanceElement.setAttributeNode(fromPos)\n        const toPos = document.createAttribute('to-pos')\n        toPos.value = 'center'\n        connectionAppearanceElement.setAttributeNode(toPos)\n        const arrow = document.createAttribute('arrowhead')\n        arrow.value = 'yes'\n        connectionAppearanceElement.setAttributeNode(arrow)\n        connectionAppearanceList.appendChild(connectionAppearanceElement)\n        connectionID++\n      }\n\n      for (let i = 0; i < linkingPhrase.toConcepts.length; i++) {\n        const toConceptID = linkingPhrase.toConcepts[i]\n        const connectionElement = xmlDoc.createElement('connection')\n        id = document.createAttribute('id')\n        id.value = connectionID.toString()\n        connectionElement.setAttributeNode(id)\n        const fromID = document.createAttribute('from-id')\n        fromID.value = linkingPhrase.id\n        connectionElement.setAttributeNode(fromID)\n        const toID = document.createAttribute('to-id')\n        toID.value = toConceptID\n        connectionElement.setAttributeNode(toID)\n        connectionList.appendChild(connectionElement)\n        const connectionAppearanceElement = xmlDoc.createElement('connection-appearance')\n        id = document.createAttribute('id')\n        id.value = connectionID.toString()\n        connectionAppearanceElement.setAttributeNode(id)\n        const fromPos = document.createAttribute('from-pos')\n        fromPos.value = 'center'\n        connectionAppearanceElement.setAttributeNode(fromPos)\n        const toPos = document.createAttribute('to-pos')\n        toPos.value = 'center'\n        connectionAppearanceElement.setAttributeNode(toPos)\n        const arrow = document.createAttribute('arrowhead')\n        arrow.value = 'yes'\n        connectionAppearanceElement.setAttributeNode(arrow)\n        connectionAppearanceList.appendChild(connectionAppearanceElement)\n        connectionID++\n      }\n    }\n\n    // Create cmap-parts-list\n    const cmapPartsList = xmlDoc.createElement('cmap-parts-list')\n    // Annotations\n    const annotation = xmlDoc.createElement('annotations')\n    const annotationXmlns = document.createAttribute('xmlns')\n    annotationXmlns.value = 'http://cmap.ihmc.us/xml/cmap/'\n    annotation.setAttributeNode(annotationXmlns)\n    const annotationList = xmlDoc.createElement('annotation-list')\n    annotation.appendChild(annotationList)\n    const annotationAppearanceList = xmlDoc.createElement('annotation-appearance-list')\n    annotation.appendChild(annotationAppearanceList)\n    cmapPartsList.appendChild(annotation)\n    cmapElement.appendChild(cmapPartsList)\n\n    if (exportType === 'archiveFile') {\n      ExportCXLArchiveFile.export(xmlDoc, urlFiles)\n    } else if (exportType === 'cmapCloud') {\n      if (mappingAnnotation) {\n        ExportCmapCloud.export(xmlDoc, urlFiles, userData, window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud(), mappingAnnotation)\n      } else {\n        ExportCmapCloud.export(xmlDoc, urlFiles, userData, window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud())\n      }\n    }\n  }\n\n  static createCmapFromCmapCloud (group, codebook, groupName, userData) {\n    const xmlDoc = document.implementation.createDocument(null, 'cmap', null)\n    const cmapElement = xmlDoc.firstChild\n    // Create processing instruction\n    // let pi = xmlDoc.createProcessingInstruction('xml', 'version=\"1.0\" encoding=\"UTF-8\"')\n    // xmlDoc.insertBefore(pi, xmlDoc.firstChild)\n    // Create map xmlns:dcterms attribute\n    const att = document.createAttribute('xmlns:dcterms')\n    att.value = 'http://purl.org/dc/terms/'\n    cmapElement.setAttributeNode(att)\n\n    // Create map xmlns attribute\n    const att1 = document.createAttribute('xmlns')\n    att1.value = 'http://cmap.ihmc.us/xml/cmap/'\n    cmapElement.setAttributeNode(att1)\n\n    // Create map xmlns:dc attribute\n    const att2 = document.createAttribute('xmlns:dc')\n    att2.value = 'http://purl.org/dc/elements/1.1/'\n    cmapElement.setAttributeNode(att2)\n\n    // Create map xmlns:vcard attribute\n    const att3 = document.createAttribute('xmlns:vcard')\n    att3.value = 'http://www.w3.org/2001/vcard-rdf/3.0#'\n    cmapElement.setAttributeNode(att3)\n\n    // Create metadata\n    const metadata = xmlDoc.createElement('res-meta')\n    cmapElement.appendChild(metadata)\n\n    // Set title\n    const title = xmlDoc.createElement('dc:title')\n    title.textContent = LanguageUtils.camelize(group.name) + '(' + group.id + ')'\n    metadata.appendChild(title)\n\n    // Set focus question\n    const focusQuestion = xmlDoc.createElement('dc:description')\n    focusQuestion.textContent = groupName\n    metadata.appendChild(focusQuestion)\n\n    // Set keywords\n    const dimensionsTag = xmlDoc.createElement('dc:subject')\n    let dimensionsString = ''\n    codebook.dimensions.forEach(dimension => {\n      dimensionsString = dimensionsString + dimension.name + ';'\n    })\n    dimensionsString = dimensionsString.slice(0, -1)\n    dimensionsTag.textContent = dimensionsString\n    metadata.appendChild(dimensionsTag)\n\n    // Set keywords\n    const urlsTag = xmlDoc.createElement('dc:language')\n    const urlString = codebook.readingMaterials\n    urlsTag.textContent = urlString\n    metadata.appendChild(urlsTag)\n\n    // Set Hypothes.is group\n    const rights = xmlDoc.createElement('dcterms:rightsHolder')\n    const creator = xmlDoc.createElement('dc:creator')\n    const contributor = xmlDoc.createElement('dc:contributor')\n    const groupId = xmlDoc.createElement('vcard:FN')\n    groupId.textContent = group.id\n    rights.appendChild(groupId)\n    creator.appendChild(groupId)\n    contributor.appendChild(groupId)\n    metadata.appendChild(rights)\n    metadata.appendChild(creator)\n    metadata.appendChild(contributor)\n\n    // Create map\n    const map = xmlDoc.createElement('map')\n    cmapElement.appendChild(map)\n\n    // Concept list\n    const conceptList = xmlDoc.createElement('concept-list')\n    map.appendChild(conceptList)\n\n    // linking phrase list\n    const linkingPhraseList = xmlDoc.createElement('linking-phrase-list')\n    map.appendChild(linkingPhraseList)\n\n    // connection list\n    const connectionList = xmlDoc.createElement('connection-list')\n    map.appendChild(connectionList)\n    // resource-group-list\n    const resourceGroupList = xmlDoc.createElement('resource-group-list')\n    map.appendChild(resourceGroupList)\n    // concept appearance list\n    const conceptAppearanceList = xmlDoc.createElement('concept-appearance-list')\n    map.appendChild(conceptAppearanceList)\n\n    // linking appearance list\n    const linkingAppearanceList = xmlDoc.createElement('linking-phrase-appearance-list')\n    map.appendChild(linkingAppearanceList)\n\n    // connection appearance list\n    const connectionAppearanceList = xmlDoc.createElement('connection-appearance-list')\n    map.appendChild(connectionAppearanceList)\n    // styleSheetList\n    const styleSheetList = xmlDoc.createElement('style-sheet-list')\n\n    const styleSheetDefault = xmlDoc.createElement('style-sheet')\n    const styleSheetIdDefault = document.createAttribute('id')\n    styleSheetIdDefault.value = '_Default_'\n    styleSheetDefault.setAttributeNode(styleSheetIdDefault)\n\n    const mapStyle = xmlDoc.createElement('map-style')\n    const mapStyleBackgroundColor = document.createAttribute('background-color')\n    mapStyleBackgroundColor.value = '255,255,255,255'\n    mapStyle.setAttributeNode(mapStyleBackgroundColor)\n    styleSheetDefault.appendChild(mapStyle)\n\n    const styleSheetLatest = xmlDoc.createElement('style-sheet')\n    const styleSheetIdLatest = document.createAttribute('id')\n    styleSheetIdLatest.value = '_LatestChanges_'\n    styleSheetLatest.setAttributeNode(styleSheetIdLatest)\n\n    styleSheetList.appendChild(styleSheetDefault)\n    styleSheetList.appendChild(styleSheetLatest)\n    map.appendChild(styleSheetList)\n\n    // Add meta-concepts\n    const dimensions = codebook.dimensions\n    for (let i = 0; i < dimensions.length; i++) {\n      const dimension = dimensions[i]\n      const dimensionElement = xmlDoc.createElement('concept')\n      let id = document.createAttribute('id')\n      id.value = dimension.id\n      dimensionElement.setAttributeNode(id)\n      const label = document.createAttribute('label')\n      if (dimension.isMisc) {\n        label.value = Config.miscDimensionName\n      } else {\n        label.value = dimension.name\n      }\n      dimensionElement.setAttributeNode(label)\n      conceptList.appendChild(dimensionElement)\n      const dimensionAppearance = xmlDoc.createElement('concept-appearance')\n      id = document.createAttribute('id')\n      const elementID = dimension.id\n      id.value = elementID\n      dimensionAppearance.setAttributeNode(id)\n      const background = document.createAttribute('background-color')\n      background.value = ColorUtils.turnForCmapCloud(dimension.color)\n      dimensionAppearance.setAttributeNode(background)\n      const font = document.createAttribute('font-style')\n      font.value = 'italic|bold'\n      dimensionAppearance.setAttributeNode(font)\n      const border = document.createAttribute('border-style')\n      border.value = 'dashed'\n      dimensionAppearance.setAttributeNode(border)\n      const fontSize = document.createAttribute('font-size')\n      fontSize.value = '18'\n      dimensionAppearance.setAttributeNode(fontSize)\n      conceptAppearanceList.appendChild(dimensionAppearance)\n    }\n    // Add concepts\n    const concepts = codebook.themes\n    for (let i = 0; i < concepts.length; i++) {\n      const concept = concepts[i]\n      if (concept.name !== 'misc') {\n        const conceptElement = xmlDoc.createElement('concept')\n        let id = document.createAttribute('id')\n        id.value = concept.id\n        conceptElement.setAttributeNode(id)\n        const label = document.createAttribute('label')\n        if (concept.topic !== '') {\n          label.value = concept.topic\n        } else {\n          label.value = concept.name\n        }\n        conceptElement.setAttributeNode(label)\n        conceptList.appendChild(conceptElement)\n        const conceptAppearance = xmlDoc.createElement('concept-appearance')\n        id = document.createAttribute('id')\n        const elementID = concept.id\n        id.value = elementID\n        conceptAppearance.setAttributeNode(id)\n        const background = document.createAttribute('background-color')\n        if (concept.isTopic) {\n          background.value = ColorUtils.turnForCmapCloud(ColorUtils.getTopicColor())\n          conceptAppearance.setAttributeNode(background)\n        } else {\n          const dimension = codebook.getDimensionByName(concept.dimension)\n          if (dimension) {\n            background.value = ColorUtils.turnForCmapCloud(dimension.color)\n            conceptAppearance.setAttributeNode(background)\n          }\n        }\n        // font-size=\"14\"\n        const fontSize = document.createAttribute('font-size')\n        fontSize.value = '14'\n        conceptAppearance.setAttributeNode(fontSize)\n        conceptAppearanceList.appendChild(conceptAppearance)\n      }\n    }\n    // Create cmap-parts-list\n    const cmapPartsList = xmlDoc.createElement('cmap-parts-list')\n    // Annotations\n    const annotation = xmlDoc.createElement('annotations')\n    const annotationXmlns = document.createAttribute('xmlns')\n    annotationXmlns.value = 'http://cmap.ihmc.us/xml/cmap/'\n    annotation.setAttributeNode(annotationXmlns)\n    const annotationList = xmlDoc.createElement('annotation-list')\n    annotation.appendChild(annotationList)\n    const annotationAppearanceList = xmlDoc.createElement('annotation-appearance-list')\n    annotation.appendChild(annotationAppearanceList)\n    cmapPartsList.appendChild(annotation)\n    cmapElement.appendChild(cmapPartsList)\n    // Export Cmap\n    ExportCmapCloud.exportFirstMap(groupName, xmlDoc, userData, group, dimensionsString)\n  }\n\n  static findLinkingPhrase (linkingPhrases, relation) {\n    const foundLinkingPhrase = _.find(linkingPhrases, (linkingPhrase) => {\n      return (linkingPhrase.linkingWord === relation.linkingWord) && (linkingPhrase.fromConcepts.includes(relation.fromConcept.id) || linkingPhrase.toConcepts.includes(relation.toConcept.id))\n    })\n    return foundLinkingPhrase\n  }\n\n  static mergeLinkingPhrases (linkingPhrases, relationships) {\n    for (let i = 0; i < relationships.length; i++) {\n      let relation = relationships[i]\n      let linkingPhrase = this.findLinkingPhrase(linkingPhrases, relation)\n      if (linkingPhrase) {\n        if (!linkingPhrase.fromConcepts.includes(relation.fromConcept.id)) {\n          linkingPhrase.fromConcepts.push(relation.fromConcept.id)\n        }\n        if (!linkingPhrase.toConcepts.includes(relation.toConcept.id)) {\n          linkingPhrase.toConcepts.push(relation.toConcept.id)\n        }\n        linkingPhrase.evidenceAnnotations = linkingPhrase.evidenceAnnotations.concat(relation.evidenceAnnotations)\n      } else {\n        const linkingPhraseToAdd = new LinkingPhrase(relation.linkingWord, relation.id)\n        linkingPhraseToAdd.fromConcepts.push(relation.fromConcept.id)\n        linkingPhraseToAdd.toConcepts.push(relation.toConcept.id)\n        linkingPhraseToAdd.evidenceAnnotations = linkingPhraseToAdd.evidenceAnnotations.concat(relation.evidenceAnnotations)\n        linkingPhrases.push(linkingPhraseToAdd)\n      }\n    }\n    return linkingPhrases\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/scripts/importExport/cmap/CXLExporter.js b/app/scripts/importExport/cmap/CXLExporter.js
--- a/app/scripts/importExport/cmap/CXLExporter.js	(revision 356f155a8605a6ee982a9eda44ad60c00d912852)
+++ b/app/scripts/importExport/cmap/CXLExporter.js	(date 1696952550247)
@@ -163,7 +163,11 @@
       id.value = dimension.id
       dimensionElement.setAttributeNode(id)
       const label = document.createAttribute('label')
-      label.value = dimension.name
+      if (dimension.isMisc) {
+        label.value = Config.miscDimensionName
+      } else {
+        label.value = dimension.name
+      }
       dimensionElement.setAttributeNode(label)
       conceptList.appendChild(dimensionElement)
       const dimensionAppearance = xmlDoc.createElement('concept-appearance')
@@ -209,17 +213,23 @@
       if (concept.theme.isTopic) {
         background.value = ColorUtils.turnForCmapCloud(ColorUtils.getTopicColor())
         conceptAppearance.setAttributeNode(background)
+        const font = document.createAttribute('font-style')
+        font.value = 'bold'
+        conceptAppearance.setAttributeNode(font)
+        const fontSize = document.createAttribute('font-size')
+        fontSize.value = '16'
+        conceptAppearance.setAttributeNode(fontSize)
       } else {
         const dimension = window.abwa.codebookManager.codebookReader.codebook.getDimensionByName(concept.theme.dimension)
         if (dimension) {
           background.value = ColorUtils.turnForCmapCloud(dimension.color)
           conceptAppearance.setAttributeNode(background)
         }
-      }
-      // font-size="14"
-      const fontSize = document.createAttribute('font-size')
-      fontSize.value = '14'
-      conceptAppearance.setAttributeNode(fontSize)
+        // font-size="14"
+        const fontSize = document.createAttribute('font-size')
+        fontSize.value = '14'
+        conceptAppearance.setAttributeNode(fontSize)
+      }
       conceptAppearanceList.appendChild(conceptAppearance)
       if (concept.evidenceAnnotations.length > 0) {
         for (let i = 0; i < concept.evidenceAnnotations.length; i++) {
@@ -357,9 +367,7 @@
       ExportCXLArchiveFile.export(xmlDoc, urlFiles)
     } else if (exportType === 'cmapCloud') {
       if (mappingAnnotation) {
-        ExportCmapCloud.export(xmlDoc, urlFiles, userData, window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud(), mappingAnnotation)
-      } else {
-        ExportCmapCloud.export(xmlDoc, urlFiles, userData, window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud())
+        ExportCmapCloud.export(xmlDoc, urlFiles, userData, window.abwa.codebookManager.codebookReader.codebook.getDimensionsForCmapCloud(), urlString, mappingAnnotation)
       }
     }
   }
@@ -543,20 +551,24 @@
         id.value = elementID
         conceptAppearance.setAttributeNode(id)
         const background = document.createAttribute('background-color')
+        const fontSize = document.createAttribute('font-size')
         if (concept.isTopic) {
+          const font = document.createAttribute('font-style')
           background.value = ColorUtils.turnForCmapCloud(ColorUtils.getTopicColor())
           conceptAppearance.setAttributeNode(background)
+          font.value = 'bold'
+          conceptAppearance.setAttributeNode(font)
+          fontSize.value = '16'
+          conceptAppearance.setAttributeNode(fontSize)
         } else {
           const dimension = codebook.getDimensionByName(concept.dimension)
           if (dimension) {
             background.value = ColorUtils.turnForCmapCloud(dimension.color)
             conceptAppearance.setAttributeNode(background)
           }
-        }
-        // font-size="14"
-        const fontSize = document.createAttribute('font-size')
-        fontSize.value = '14'
-        conceptAppearance.setAttributeNode(fontSize)
+          fontSize.value = '14'
+          conceptAppearance.setAttributeNode(fontSize)
+        }
         conceptAppearanceList.appendChild(conceptAppearance)
       }
     }
@@ -574,7 +586,7 @@
     cmapPartsList.appendChild(annotation)
     cmapElement.appendChild(cmapPartsList)
     // Export Cmap
-    ExportCmapCloud.exportFirstMap(groupName, xmlDoc, userData, group, dimensionsString)
+    ExportCmapCloud.exportFirstMap(groupName, xmlDoc, userData, group, dimensionsString, urlString, codebook)
   }
 
   static findLinkingPhrase (linkingPhrases, relation) {
